{
  "Function (pure)": {
    "prefix": "fn",
    "body": [
      "fn ${1:functionName}(${2:params}) -> ${3:ReturnType} {",
      "  $0",
      "}"
    ],
    "description": "Define a pure function"
  },
  "Function with @policy + Net Effect": {
    "prefix": "fnnet",
    "body": [
      "@policy(${1|READ_ONLY,WRITE_OPERATIONS,DELETE_OPERATIONS,ADMIN_ONLY,SYSTEM_INTERNAL,AI_SUGGESTIONS,EXTERNAL_API|})",
      "fn ${2:functionName}(tenant_id: String${3:, params}) -> Result<${4:T}, CRMError> !net {",
      "  let url = \"${5:/api/v2/endpoint}\";",
      "  let response = http.${6|get,post,put,delete|}(url${7:, { params: { tenant_id: tenant_id } }});",
      "  ",
      "  return match response {",
      "    Ok{value} => Ok(value.data),",
      "    Err{error} => CRMError.fromHTTP(url, error.status, \"${8:operation_name}\"),",
      "    _ => CRMError.network(url, 500, \"${8:operation_name}\")",
      "  };",
      "}"
    ],
    "description": "Define a function with @policy annotation and network effect"
  },
  "Function with Multiple Effects": {
    "prefix": "fneffects",
    "body": [
      "@policy(${1|READ_ONLY,WRITE_OPERATIONS,DELETE_OPERATIONS,ADMIN_ONLY|})",
      "fn ${2:functionName}(tenant_id: String${3:, params}) -> Result<${4:T}, CRMError> !net, clock {",
      "  let timestamp = clock.now();",
      "  $0",
      "}"
    ],
    "description": "Define a function with net and clock effects"
  },
  "Match Expression": {
    "prefix": "match",
    "body": [
      "match ${1:expression} {",
      "  ${2:Ok{value}} => ${3:value},",
      "  ${4:Err{error}} => ${5:error},",
      "  _ => ${6:fallback}",
      "}"
    ],
    "description": "Pattern match expression"
  },
  "Match Result with CRMError": {
    "prefix": "matchres",
    "body": [
      "match ${1:response} {",
      "  Ok{value} => Ok(${2:value.data}),",
      "  Err{error} => CRMError.fromHTTP(${3:url}, error.status, \"${4:operation}\"),",
      "  _ => CRMError.network(${3:url}, 500, \"${4:operation}\")",
      "}"
    ],
    "description": "Pattern match a Result type with CRMError.fromHTTP"
  },
  "Match Result with Block Body": {
    "prefix": "matchblock",
    "body": [
      "match ${1:response} {",
      "  Ok{value} => {",
      "    let ${2:data} = value.data;",
      "    ${3:Ok(data)}",
      "  },",
      "  Err{error} => CRMError.fromHTTP(${4:url}, error.status, \"${5:op}\"),",
      "  _ => CRMError.network(${4:url}, 500, \"${5:op}\")",
      "}"
    ],
    "description": "Pattern match with block body in Ok arm"
  },
  "Type Alias": {
    "prefix": "type",
    "body": [
      "type ${1:TypeName} = ${2:BaseType}"
    ],
    "description": "Type alias"
  },
  "Record Type": {
    "prefix": "typerec",
    "body": [
      "type ${1:TypeName} = {",
      "  ${2:field1}: ${3:String},",
      "  ${4:field2}: ${5:Number}",
      "}"
    ],
    "description": "Record type definition"
  },
  "Union Error Type": {
    "prefix": "error",
    "body": [
      "type ${1:ErrorName} = ",
      "  | NotFound { entity: String, id: String }",
      "  | ValidationError { field: String, message: String }",
      "  | PermissionDenied { operation: String, role: String }",
      "  | NetworkError { url: String, code: Number }"
    ],
    "description": "Union error type definition matching CRMError"
  },
  "Let Binding": {
    "prefix": "let",
    "body": [
      "let ${1:name}: ${2:Type} = ${3:value};"
    ],
    "description": "Typed let binding"
  },
  "Let Binding (untyped)": {
    "prefix": "letv",
    "body": [
      "let ${1:name} = ${2:value};"
    ],
    "description": "Untyped let binding"
  },
  "HTTP GET": {
    "prefix": "httpget",
    "body": [
      "let response = http.get(${1:url}, { params: { tenant_id: tenant_id } });"
    ],
    "description": "HTTP GET request with tenant isolation"
  },
  "HTTP POST": {
    "prefix": "httppost",
    "body": [
      "let response = http.post(${1:url}, { body: { tenant_id: tenant_id, ${2:field: value} } });"
    ],
    "description": "HTTP POST request with tenant isolation"
  },
  "HTTP PUT": {
    "prefix": "httpput",
    "body": [
      "let response = http.put(${1:url}, { body: { tenant_id: tenant_id, ${2:field: value} } });"
    ],
    "description": "HTTP PUT request with tenant isolation"
  },
  "HTTP DELETE": {
    "prefix": "httpdel",
    "body": [
      "let response = http.delete(${1:url}, { params: { tenant_id: tenant_id } });"
    ],
    "description": "HTTP DELETE request with tenant isolation"
  },
  "Ok Result": {
    "prefix": "ok",
    "body": [
      "Ok(${1:value})"
    ],
    "description": "Ok result constructor"
  },
  "CRMError.fromHTTP": {
    "prefix": "errhttpfrom",
    "body": [
      "CRMError.fromHTTP(${1:url}, ${2:error.status}, \"${3:operation}\")"
    ],
    "description": "CRMError.fromHTTP — maps HTTP status to semantic error type"
  },
  "CRMError.notFound": {
    "prefix": "errnotfound",
    "body": [
      "CRMError.notFound(\"${1:entity}\", ${2:id}, \"${3:operation}\")"
    ],
    "description": "CRMError.notFound — 404 entity not found"
  },
  "CRMError.validation": {
    "prefix": "errval",
    "body": [
      "CRMError.validation(\"${1:fn}\", \"${2:field}\", \"${3:message}\")"
    ],
    "description": "CRMError.validation — 400 validation error"
  },
  "CRMError.forbidden": {
    "prefix": "errforbid",
    "body": [
      "CRMError.forbidden(\"${1:operation}\", \"${2:role}\", \"${3:required}\")"
    ],
    "description": "CRMError.forbidden — 403 permission denied"
  },
  "CRMError.network": {
    "prefix": "errnet",
    "body": [
      "CRMError.network(${1:url}, ${2:500}, \"${3:operation}\")"
    ],
    "description": "CRMError.network — 5xx server/network error"
  },
  "Import Types": {
    "prefix": "import",
    "body": [
      "import { ${1:Result, Lead, CRMError} } from \"${2:../../spec/types.braid}\""
    ],
    "description": "Import statement"
  },
  "@policy Annotation": {
    "prefix": "@policy",
    "body": [
      "@policy(${1|READ_ONLY,WRITE_OPERATIONS,DELETE_OPERATIONS,ADMIN_ONLY,SYSTEM_INTERNAL,AI_SUGGESTIONS,EXTERNAL_API|})"
    ],
    "description": "Policy annotation for function-level access control"
  },
  "CRM Read Tool Template": {
    "prefix": "crmread",
    "body": [
      "@policy(READ_ONLY)",
      "fn ${1:get}${2:Leads}(tenant_id: String${3:, id: String}) -> Result<${4:Lead}, CRMError> !net {",
      "  let url = \"/api/v2/${5:leads}\";",
      "  let response = http.get(url, { params: { tenant_id: tenant_id${6:, id: id} } });",
      "  ",
      "  return match response {",
      "    Ok{value} => Ok(value.data),",
      "    Err{error} => CRMError.fromHTTP(url, error.status, \"${7:get_leads}\"),",
      "    _ => CRMError.network(url, 500, \"${7:get_leads}\")",
      "  };",
      "}"
    ],
    "description": "CRM read-only tool with @policy(READ_ONLY)"
  },
  "CRM Write Tool Template": {
    "prefix": "crmwrite",
    "body": [
      "@policy(WRITE_OPERATIONS)",
      "fn ${1:create}${2:Lead}(tenant_id: String, ${3:data: Object}) -> Result<${4:Lead}, CRMError> !net {",
      "  let url = \"/api/v2/${5:leads}\";",
      "  let payload = {",
      "    tenant_id: tenant_id,",
      "    ${6:field: value}",
      "  };",
      "  ",
      "  let response = http.post(url, { body: payload });",
      "  ",
      "  return match response {",
      "    Ok{value} => Ok(value.data),",
      "    Err{error} => CRMError.fromHTTP(url, error.status, \"${7:create_lead}\"),",
      "    _ => CRMError.network(url, 500, \"${7:create_lead}\")",
      "  };",
      "}"
    ],
    "description": "CRM write tool with @policy(WRITE_OPERATIONS)"
  },
  "CRM Delete Tool Template": {
    "prefix": "crmdelete",
    "body": [
      "@policy(DELETE_OPERATIONS)",
      "fn ${1:delete}${2:Lead}(tenant_id: String, id: String) -> Result<${3:Boolean}, CRMError> !net {",
      "  let url = \"/api/v2/${4:leads}/\" + id;",
      "  let response = http.delete(url, { params: { tenant_id: tenant_id } });",
      "  ",
      "  return match response {",
      "    Ok{value} => Ok(true),",
      "    Err{error} => CRMError.fromHTTP(url, error.status, \"${5:delete_lead}\"),",
      "    _ => CRMError.network(url, 500, \"${5:delete_lead}\")",
      "  };",
      "}"
    ],
    "description": "CRM delete tool with @policy(DELETE_OPERATIONS)"
  },
  "Search Tool Template": {
    "prefix": "crmsearch",
    "body": [
      "@policy(READ_ONLY)",
      "fn search${1:Leads}(tenant_id: String, query: String, limit: Number) -> Result<Array<${2:Lead}>, CRMError> !net {",
      "  let url = \"/api/v2/${3:leads}\";",
      "  let response = http.get(url, { params: { tenant_id: tenant_id, q: query, limit: limit } });",
      "  ",
      "  return match response {",
      "    Ok{value} => Ok(value.data),",
      "    Err{error} => CRMError.fromHTTP(url, error.status, \"search_${3:leads}\"),",
      "    _ => CRMError.network(url, 500, \"search_${3:leads}\")",
      "  };",
      "}"
    ],
    "description": "CRM search tool with tenant and limit"
  },
  "Validation Function": {
    "prefix": "validate",
    "body": [
      "fn validate${1:Email}(${2:email}: String) -> Boolean {",
      "  let ${3:hasAt} = includes(${2:email}, \"@\");",
      "  let ${4:hasDot} = includes(${2:email}, \".\");",
      "  return ${3:hasAt} && ${4:hasDot};",
      "}"
    ],
    "description": "Pure validation function"
  },
  "If-Else": {
    "prefix": "if",
    "body": [
      "if ${1:condition} {",
      "  ${2:// then}",
      "} else {",
      "  ${3:// else}",
      "}"
    ],
    "description": "If-else statement"
  },
  "If Guard (early return)": {
    "prefix": "ifguard",
    "body": [
      "if ${1:response}.tag == \"Err\" {",
      "  return CRMError.fromHTTP(${2:url}, ${1:response}.error.status, \"${3:operation}\");",
      "}"
    ],
    "description": "Guard clause with early return on error"
  }
}
