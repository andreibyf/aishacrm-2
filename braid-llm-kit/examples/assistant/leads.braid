// Executive Assistant Tools - Lead Management
// Create, update, convert leads to accounts

import { Result, Lead, CRMError } from "../../spec/types.braid"

// Error handling note: HTTP errors return CRMError with specific tags based on status code.
// The backend summarizeToolResult function interprets these error codes to provide
// appropriate user-facing messages.
// - 400 = ValidationError
// - 401/403 = PermissionDenied  
// - 404 = NotFound
// - 5xx = NetworkError

@policy(WRITE_OPERATIONS)
fn createLead(
  tenant_id: String,
  first_name: String,
  last_name: String,
  email: String,
  company: String,
  phone: String,
  source: String
) -> Result<Lead, CRMError> !net {
  let url = "/api/v2/leads";
  let body = {
    tenant_id: tenant_id,
    first_name: first_name,
    last_name: last_name,
    email: email,
    company: company,
    phone: phone,
    source: source,
    status: "new",
    metadata: {}
  };
  
  let response = http.post(url, { body: body });
  
  return match response {
    Ok{value} => Ok(value.data),
    Err{error} => Err({ tag: "APIError", url: url, code: error.status, operation: "create_lead" }),
    _ => Err({ tag: "NetworkError", url: url, code: 500 })
  };
}

@policy(DELETE_OPERATIONS)
fn deleteLead(
  tenant_id: String,
  lead_id: String
) -> Result<Boolean, CRMError> !net {
  let url = "/api/v2/leads/" + lead_id;
  let response = http.delete(url, {});
  return match response {
    Ok{value} => Ok(true),
    Err{error} => Err({ tag: "APIError", url: url, code: error.status, operation: "delete_lead", entity: "Lead", id: lead_id }),
    _ => Err({ tag: "NetworkError", url: url, code: 500 })
  };
}

@policy(WRITE_OPERATIONS)
fn qualifyLead(
  tenant_id: String,
  lead_id: String,
  notes: String
) -> Result<Lead, CRMError> !net {
  // v3.0.0 workflow: Mark lead as qualified (status transition)
  // This prepares the lead for conversion to Contact + Account + Opportunity
  let url = "/api/v2/leads/" + lead_id;
  let body = {
    tenant_id: tenant_id,
    status: "qualified",
    qualification_notes: notes
  };
  
  let response = http.put(url, { body: body });
  
  return match response {
    Ok{value} => Ok(value.data),
    Err{error} => Err({ tag: "APIError", url: url, code: error.status, operation: "qualify_lead", entity: "Lead", id: lead_id }),
    _ => Err({ tag: "NetworkError", url: url, code: 500 })
  };
}

@policy(WRITE_OPERATIONS)
fn updateLead(
  tenant_id: String,
  lead_id: String,
  updates: Object
) -> Result<Lead, CRMError> !net {
  let url = "/api/v2/leads/" + lead_id;
  
  let response = http.put(url, { body: updates });
  
  return match response {
    Ok{value} => Ok(value.data),
    Err{error} => Err({ tag: "APIError", url: url, code: error.status, operation: "update_lead", entity: "Lead", id: lead_id }),
    _ => Err({ tag: "NetworkError", url: url, code: 500 })
  };
}

@policy(WRITE_OPERATIONS)
fn convertLeadToAccount(
  tenant_id: String,
  lead_id: String,
  options: Object
) -> Result<Object, CRMError> !net {
  let url = "/api/v2/leads/" + lead_id + "/convert";
  let body = options;
  
  let response = http.post(url, { body: body });
  
  return match response {
    Ok{value} => Ok(value.data),
    Err{error} => Err({ tag: "APIError", url: url, code: error.status, operation: "convert_lead", entity: "Lead", id: lead_id }),
    _ => Err({ tag: "NetworkError", url: url, code: 500 })
  };
}

@policy(READ_ONLY)
fn listLeads(
  tenant_id: String,
  status: String,
  account_id: String,
  assigned_to: String,
  limit: Number
) -> Result<Array, CRMError> !net {
  let url = "/api/v2/leads";
  
  // Build params with optional filters
  // assigned_to: pass a user/employee UUID to filter by assignment, or "unassigned" for leads with no owner
  let params = {
    tenant_id: tenant_id,
    status: status,
    account_id: account_id,
    assigned_to: assigned_to,
    limit: limit
  };
  
  let response = http.get(url, { params: params });
  
  // Note: Empty array is a VALID result (no matches), not an error
  return match response {
    Ok{value} => Ok(value.data),
    Err{error} => Err({ tag: "APIError", url: url, code: error.status, operation: "list_leads" }),
    _ => Err({ tag: "NetworkError", url: url, code: 500 })
  };
}

@policy(READ_ONLY)
fn getLeadDetails(
  tenant_id: String,
  lead_id: String
) -> Result<Lead, CRMError> !net {
  let url = "/api/v2/leads/" + lead_id;
  let params = { tenant_id: tenant_id };
  
  let response = http.get(url, { params: params });
  
  return match response {
    Ok{value} => Ok(value.data),
    Err{error} => Err({ tag: "APIError", url: url, code: error.status, operation: "get_lead", entity: "Lead", id: lead_id }),
    _ => Err({ tag: "NetworkError", url: url, code: 500 })
  };
}

@policy(READ_ONLY)
fn searchLeads(
  tenant_id: String,
  query: String,
  assigned_to: String,
  limit: Number
) -> Result<Array, CRMError> !net {
  // Use list endpoint - v2 leads doesn't have dedicated search
  let url = "/api/v2/leads";
  let params = {
    tenant_id: tenant_id,
    limit: limit,
    query: query,
    assigned_to: assigned_to
  };
  
  let response = http.get(url, { params: params });
  
  // Note: Empty array is a VALID result (no matches found), not an error
  // The AI should NOT report "network error" for empty search results
  return match response {
    Ok{value} => Ok(value.data.leads),
    Err{error} => Err({ tag: "APIError", url: url, code: error.status, operation: "search_leads", query: query }),
    _ => Err({ tag: "NetworkError", url: url, code: 500 })
  };
}

// Search leads by status - returns full lead details for leads matching a specific status
// Use this when user asks about leads with a specific status (e.g. "my warm leads", "new leads")
// Status values: new, contacted, qualified, warm, hot, cold, lost, converted
@policy(READ_ONLY)
fn searchLeadsByStatus(
  tenant_id: String,
  status: String,
  limit: Number
) -> Result<Array, CRMError> !net {
  let url = "/api/v2/leads";
  let params = {
    tenant_id: tenant_id,
    status: status,
    limit: limit
  };
  
  let response = http.get(url, { params: params });
  
  // Returns full lead details including name, company, email, phone, etc.
  return match response {
    Ok{value} => Ok(value.data),
    Err{error} => Err({ tag: "APIError", url: url, code: error.status, operation: "search_leads_by_status", status: status }),
    _ => Err({ tag: "NetworkError", url: url, code: 500 })
  };
}
