// Executive Assistant Tools - Activity & Calendar Management
// Schedule meetings, track tasks, manage calendar

import { Result, Activity, CRMError } from "../../spec/types.braid"

// Error handling: HTTP errors return CRMError with APIError tag and status code.
// The backend interprets status codes to determine error type.

@policy(WRITE_OPERATIONS)
fn createActivity(
  tenant_id: String,
  subject: String,
  activity_type: String,
  due_date: String,
  due_time: String,
  assigned_to: String,
  entity_type: String,
  entity_id: String,
  body: String
) -> Result<Activity, CRMError> !net {
  let url = "/api/v2/activities";
  // Transform entity_type/entity_id to DB column names: related_to/related_id
  let payload = {
    tenant_id: tenant_id,
    subject: subject,
    activity_type: activity_type,
    due_date: due_date,
    due_time: due_time,
    assigned_to: assigned_to,
    related_to: entity_type,
    related_id: entity_id,
    body: body,
    status: "scheduled",
    metadata: {}
  };
  
  let response = http.post(url, { body: payload });
  
  return match response {
    Ok{value} => Ok(value.data),
    Err{error} => Err({ tag: "APIError", url: url, code: error.status, operation: "create_activity" }),
    _ => Err({ tag: "NetworkError", url: url, code: 500 })
  };
}

@policy(WRITE_OPERATIONS)
fn updateActivity(
  tenant_id: String,
  activity_id: String,
  updates: Object
) -> Result<Activity, CRMError> !net {
  let url = "/api/v2/activities/" + activity_id;
  
  let response = http.put(url, { body: updates });
  
  return match response {
    Ok{value} => Ok(value.data),
    Err{error} => Err({ tag: "APIError", url: url, code: error.status, operation: "update_activity", entity: "Activity", id: activity_id }),
    _ => Err({ tag: "NetworkError", url: url, code: 500 })
  };
}

@policy(WRITE_OPERATIONS)
fn markActivityComplete(
  tenant_id: String,
  activity_id: String
) -> Result<Activity, CRMError> !net {
  let url = "/api/v2/activities/" + activity_id;
  let updates = { status: "completed" };
  
  let response = http.put(url, { body: updates });
  
  return match response {
    Ok{value} => Ok(value.data),
    Err{error} => Err({ tag: "APIError", url: url, code: error.status, operation: "complete_activity", entity: "Activity", id: activity_id }),
    _ => Err({ tag: "NetworkError", url: url, code: 500 })
  };
}

@policy(READ_ONLY)
fn getUpcomingActivities(
  tenant_id: String,
  assigned_to: String,
  days: Number
) -> Result<Array, CRMError> !net {
  let url = "/api/v2/activities";
  // TODO: Filter by due_date range using days param when API supports date range queries
  let params = {
    tenant_id: tenant_id,
    assigned_to: assigned_to,
    status: "scheduled",
    limit: days * 10
  };
  
  let response = http.get(url, { params: params });
  
  // Note: Empty array is a VALID result (no upcoming activities), not an error
  return match response {
    Ok{value} => Ok(value.data),
    Err{error} => Err({ tag: "APIError", url: url, code: error.status, operation: "list_activities" }),
    _ => Err({ tag: "NetworkError", url: url, code: 500 })
  };
}

@policy(WRITE_OPERATIONS)
fn scheduleMeeting(
  tenant_id: String,
  subject: String,
  attendees: Array,
  date_time: String,
  duration_minutes: Number,
  assigned_to: String
) -> Result<Activity, CRMError> !net {
  let url = "/api/v2/activities";
  let attendee_list = attendees.join(", ");
  let payload = {
    tenant_id: tenant_id,
    subject: subject,
    activity_type: "meeting",
    due_date: date_time,
    assigned_to: assigned_to,
    body: "Attendees: " + attendee_list,
    status: "scheduled",
    metadata: { duration_minutes: duration_minutes, attendees: attendees }
  };
  
  let response = http.post(url, { body: payload });
  
  return match response {
    Ok{value} => Ok(value.data),
    Err{error} => Err({ tag: "APIError", url: url, code: error.status, operation: "schedule_meeting" }),
    _ => Err({ tag: "NetworkError", url: url, code: 500 })
  };
}

@policy(DELETE_OPERATIONS)
fn deleteActivity(
  tenant_id: String,
  activity_id: String
) -> Result<Boolean, CRMError> !net {
  let url = "/api/v2/activities/" + activity_id;
  let response = http.delete(url, {});
  return match response {
    Ok{value} => Ok(true),
    Err{error} => Err({ tag: "APIError", url: url, code: error.status, operation: "delete_activity", entity: "Activity", id: activity_id }),
    _ => Err({ tag: "NetworkError", url: url, code: 500 })
  };
}

@policy(READ_ONLY)
fn listActivities(
  tenant_id: String,
  status: String,
  entity_type: String,
  entity_id: String,
  assigned_to: String,
  limit: Number
) -> Result<Array, CRMError> !net {
  let url = "/api/v2/activities";
  // entity_type: lead, contact, account, opportunity
  // API query params use related_to_type/related_to_id
  let params = {
    tenant_id: tenant_id,
    status: status,
    related_to_type: entity_type,
    related_to_id: entity_id,
    assigned_to: assigned_to,
    limit: limit
  };
  
  let response = http.get(url, { params: params });
  
  // Note: Empty array is a VALID result (no activities match filter), not an error
  return match response {
    Ok{value} => Ok(value.data),
    Err{error} => Err({ tag: "APIError", url: url, code: error.status, operation: "list_activities" }),
    _ => Err({ tag: "NetworkError", url: url, code: 500 })
  };
}

@policy(READ_ONLY)
fn getActivityDetails(
  tenant_id: String,
  activity_id: String
) -> Result<Activity, CRMError> !net {
  let url = "/api/v2/activities/" + activity_id;
  let params = { tenant_id: tenant_id };
  
  let response = http.get(url, { params: params });
  
  return match response {
    Ok{value} => Ok(value.data),
    Err{error} => Err({ tag: "APIError", url: url, code: error.status, operation: "get_activity", entity: "Activity", id: activity_id }),
    _ => Err({ tag: "NetworkError", url: url, code: 500 })
  };
}

@policy(READ_ONLY)
fn searchActivities(
  tenant_id: String,
  query: String,
  assigned_to: String,
  limit: Number
) -> Result<Array, CRMError> !net {
  // Use list endpoint with search param - filters by subject
  let url = "/api/v2/activities";
  let params = {
    tenant_id: tenant_id,
    search: query,
    assigned_to: assigned_to,
    limit: limit
  };
  
  let response = http.get(url, { params: params });
  
  // Note: Empty array is a VALID result (no matches found), not an error
  return match response {
    Ok{value} => Ok(value.data.activities),
    Err{error} => Err({ tag: "APIError", url: url, code: error.status, operation: "search_activities", query: query }),
    _ => Err({ tag: "NetworkError", url: url, code: 500 })
  };
}
