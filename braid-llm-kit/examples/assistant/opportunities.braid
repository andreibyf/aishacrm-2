// Executive Assistant Tools - Opportunities Management
// Track sales pipeline, update stages, forecast revenue

import { Result, Opportunity, CRMError } from "../../spec/types.braid"

// Error handling: HTTP errors return CRMError with APIError tag and status code.
// The backend interprets status codes to determine error type.

@policy(WRITE_OPERATIONS)
fn createOpportunity(
  tenant_id: String,
  name: String,
  description: String,
  amount: Number,
  stage: String,
  probability: Number,
  close_date: String,
  account_id: String,
  contact_id: String,
  lead_id: String
) -> Result<Opportunity, CRMError> !net {
  let url = "/api/v2/opportunities";
  let body = {
    tenant_id: tenant_id,
    name: name,
    description: description,
    amount: amount,
    stage: stage,
    probability: probability,
    close_date: close_date,
    account_id: account_id,
    contact_id: contact_id,
    lead_id: lead_id,
    metadata: {}
  };
  
  let response = http.post(url, { body: body });
  
  return match response {
    Ok{value} => Ok(value.data),
    Err{error} => Err({ tag: "APIError", url: url, code: error.status, operation: "create_opportunity" }),
    _ => Err({ tag: "NetworkError", url: url, code: 500 })
  };
}

@policy(DELETE_OPERATIONS)
fn deleteOpportunity(
  tenant_id: String,
  opportunity_id: String
) -> Result<Boolean, CRMError> !net {
  let url = "/api/v2/opportunities/" + opportunity_id;
  let response = http.delete(url, {});
  return match response {
    Ok{value} => Ok(true),
    Err{error} => Err({ tag: "APIError", url: url, code: error.status, operation: "delete_opportunity", entity: "Opportunity", id: opportunity_id }),
    _ => Err({ tag: "NetworkError", url: url, code: 500 })
  };
}

@policy(WRITE_OPERATIONS)
fn updateOpportunity(
  tenant_id: String,
  opportunity_id: String,
  updates: Object
) -> Result<Opportunity, CRMError> !net {
  let url = "/api/v2/opportunities/" + opportunity_id;
  
  let response = http.put(url, { body: updates });
  
  return match response {
    Ok{value} => Ok(value.data),
    Err{error} => Err({ tag: "APIError", url: url, code: error.status, operation: "update_opportunity", entity: "Opportunity", id: opportunity_id }),
    _ => Err({ tag: "NetworkError", url: url, code: 500 })
  };
}

@policy(READ_ONLY)
fn listOpportunitiesByStage(
  tenant_id: String,
  stage: String,
  account_id: String,
  assigned_to: String,
  assigned_to_team: String,
  limit: Number
) -> Result<Array, CRMError> !net {
  let url = "/api/v2/opportunities";
  let params = {
    tenant_id: tenant_id,
    stage: stage,
    account_id: account_id,
    assigned_to: assigned_to,
    assigned_to_team: assigned_to_team,
    limit: limit
  };
  
  let response = http.get(url, { params: params });
  
  // Note: Empty array is a VALID result (no opportunities in this stage), not an error
  return match response {
    Ok{value} => Ok(value.data),
    Err{error} => Err({ tag: "APIError", url: url, code: error.status, operation: "list_opportunities" }),
    _ => Err({ tag: "NetworkError", url: url, code: 500 })
  };
}

@policy(READ_ONLY)
fn getOpportunityDetails(
  tenant_id: String,
  opportunity_id: String
) -> Result<Opportunity, CRMError> !net {
  let url = "/api/v2/opportunities/" + opportunity_id;
  let params = { tenant_id: tenant_id };
  
  let response = http.get(url, { params: params });
  
  return match response {
    Ok{value} => Ok(value.data),
    Err{error} => Err({ tag: "APIError", url: url, code: error.status, operation: "get_opportunity", entity: "Opportunity", id: opportunity_id }),
    _ => Err({ tag: "NetworkError", url: url, code: 500 })
  };
}

@policy(READ_ONLY)
fn searchOpportunities(
  tenant_id: String,
  query: String,
  assigned_to: String,
  assigned_to_team: String,
  limit: Number
) -> Result<Array, CRMError> !net {
  // Use list endpoint - v2 opportunities doesn't have dedicated search
  let url = "/api/v2/opportunities";
  let params = {
    tenant_id: tenant_id,
    assigned_to: assigned_to,
    assigned_to_team: assigned_to_team,
    limit: limit
  };
  
  let response = http.get(url, { params: params });
  
  // Note: Empty array is a VALID result (no matches found), not an error
  return match response {
    Ok{value} => Ok(value.data.opportunities),
    Err{error} => Err({ tag: "APIError", url: url, code: error.status, operation: "search_opportunities", query: query }),
    _ => Err({ tag: "NetworkError", url: url, code: 500 })
  };
}

// Search opportunities by stage - returns full opportunity details for opportunities in a specific stage
// Use this when user asks about opportunities in a specific pipeline stage
// Stage values: prospecting, qualification, proposal, negotiation, closed-won, closed-lost
@policy(READ_ONLY)
fn searchOpportunitiesByStage(
  tenant_id: String,
  stage: String,
  limit: Number
) -> Result<Array, CRMError> !net {
  let url = "/api/v2/opportunities";
  let params = {
    tenant_id: tenant_id,
    stage: stage,
    limit: limit
  };
  
  let response = http.get(url, { params: params });
  
  // Returns full opportunity details including name, amount, stage, probability, etc.
  return match response {
    Ok{value} => Ok(value.data),
    Err{error} => Err({ tag: "APIError", url: url, code: error.status, operation: "search_opportunities_by_stage", stage: stage }),
    _ => Err({ tag: "NetworkError", url: url, code: 500 })
  };
}

@policy(READ_ONLY)
fn getOpportunityForecast(
  tenant_id: String,
  period: String
) -> Result<Object, CRMError> !net {
  let url = "/api/reports/forecast";
  let params = {
    tenant_id: tenant_id,
    period: period
  };
  
  let response = http.get(url, { params: params });
  
  return match response {
    Ok{value} => Ok(value.data),
    Err{error} => Err({ tag: "APIError", url: url, code: error.status, operation: "get_forecast" }),
    _ => Err({ tag: "NetworkError", url: url, code: 500 })
  };
}

@policy(WRITE_OPERATIONS)
fn markOpportunityWon(
  tenant_id: String,
  opportunity_id: String,
  close_details: Object
) -> Result<Opportunity, CRMError> !net {
  let url = "/api/v2/opportunities/" + opportunity_id;
  // Extract close_date from close_details or use today
  let updates = {
    stage: "closed-won",
    probability: 100,
    close_date: close_details.close_date
  };
  
  let response = http.put(url, { body: updates });
  
  return match response {
    Ok{value} => Ok(value.data),
    Err{error} => Err({ tag: "APIError", url: url, code: error.status, operation: "mark_won", entity: "Opportunity", id: opportunity_id }),
    _ => Err({ tag: "NetworkError", url: url, code: 500 })
  };
}
