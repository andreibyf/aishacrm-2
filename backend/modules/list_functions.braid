// List & function enhancements demo module

// Helper: triple a number
fn triple(n: i32) -> i32 {
  n * 3
}

// Index into an array literal
@route(method: "GET", path: "/api/braid/second_of_literal")
fn second_of_literal() -> i32 {
  [5, 10, 15][1]
}

// Index into an array literal built from params
@route(method: "POST", path: "/api/braid/param_index")
fn param_index(a: i32, b: i32) -> i32 {
  [a, b, a + b][2]
}

// Use len() builtin on array literal
@route(method: "GET", path: "/api/braid/count_names")
fn count_names() -> i32 {
  len(["Alice", "Bob", "Charlie"])
}

// Conditional using len() and arithmetic
@route(method: "POST", path: "/api/braid/size_check")
fn size_check(x: i32) -> String {
  if len([x, x * 2, x * 3]) > 3 {
    "Large"
  } else {
    "Small"
  }
}

// Nested function calls with len() in arithmetic
@route(method: "GET", path: "/api/braid/sum_lengths")
fn sum_lengths() -> i32 {
  len([1,2]) + len(["a","b","c"]) // 2 + 3 = 5
}

// Combine helper function and indexing
@route(method: "POST", path: "/api/braid/triple_first")
fn triple_first(a: i32, b: i32, c: i32) -> i32 {
  triple([a, b, c][0])
}

// NOTE: Full map/filter/reduce require inline lambda expressions (e.g., |x| x + 1),
// which the current Braid grammar doesn't support yet. We've prepared the transpiler
// to convert these builtins once the parser allows anonymous functions.
