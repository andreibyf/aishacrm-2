#!/usr/bin/env node
/**
 * generate-braid-param-order.js
 * 
 * Parses all .braid files in examples/assistant/ and extracts function parameter
 * orders directly from the AST. Outputs a JS module that can replace the
 * hand-maintained BRAID_PARAM_ORDER in analysis.js.
 * 
 * Usage:
 *   node backend/scripts/generate-braid-param-order.js          # print to stdout
 *   node backend/scripts/generate-braid-param-order.js --check   # validate current vs parsed
 *   node backend/scripts/generate-braid-param-order.js --json    # output JSON
 * 
 * This eliminates the risk of param order drift between .braid files and
 * the execution engine (Issue #4 from braid-refactoring-issues.md).
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { parse } from '../../braid-llm-kit/tools/braid-parse.js';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const ASSISTANT_DIR = path.resolve(__dirname, '../../braid-llm-kit/examples/assistant');

function extractParamOrders() {
  const braidFiles = fs.readdirSync(ASSISTANT_DIR)
    .filter(f => f.endsWith('.braid'))
    .sort();

  const paramOrder = {};
  const errors = [];

  for (const file of braidFiles) {
    const filePath = path.join(ASSISTANT_DIR, file);
    const source = fs.readFileSync(filePath, 'utf8');

    try {
      const ast = parse(source, file);

      for (const item of ast.items) {
        if (item.type === 'FnDecl') {
          const params = (item.params || []).map(p => p.name);
          
          if (paramOrder[item.name]) {
            errors.push(`Duplicate function name '${item.name}' in ${file} (also in previous file)`);
          }
          
          paramOrder[item.name] = {
            params,
            file,
            effects: item.effects || [],
            returnType: item.returnType || null
          };
        }
      }
    } catch (err) {
      errors.push(`Parse error in ${file}: ${err.message}`);
    }
  }

  return { paramOrder, errors };
}

function generateJSBlock(paramOrder) {
  const lines = [];
  let currentFile = null;

  // Group by file
  const byFile = {};
  for (const [fnName, info] of Object.entries(paramOrder)) {
    if (!byFile[info.file]) byFile[info.file] = [];
    byFile[info.file].push({ fnName, ...info });
  }

  for (const [file, fns] of Object.entries(byFile)) {
    lines.push(`  // === ${file} ===`);
    for (const fn of fns) {
      const paramStr = fn.params.map(p => `'${p}'`).join(', ');
      lines.push(`  ${fn.fnName}: [${paramStr}],`);
    }
    lines.push('');
  }

  return lines.join('\n');
}

// --- Main ---
const args = process.argv.slice(2);
const mode = args[0] || '--print';

const { paramOrder, errors } = extractParamOrders();

if (errors.length > 0) {
  console.error('⚠️  Errors during parsing:');
  for (const err of errors) {
    console.error(`  - ${err}`);
  }
  console.error('');
}

const fnCount = Object.keys(paramOrder).length;
const fileCount = new Set(Object.values(paramOrder).map(v => v.file)).size;

if (mode === '--json') {
  // Output clean JSON (params only, no metadata)
  const clean = {};
  for (const [fn, info] of Object.entries(paramOrder)) {
    clean[fn] = info.params;
  }
  console.log(JSON.stringify(clean, null, 2));
  
} else if (mode === '--check') {
  // Validate mode: compare parsed vs what's in analysis.js
  // Import the current BRAID_PARAM_ORDER dynamically
  console.log(`✅ Parsed ${fnCount} functions from ${fileCount} .braid files\n`);
  
  // Output the parsed order for manual comparison
  for (const [fn, info] of Object.entries(paramOrder)) {
    console.log(`  ${fn}: [${info.params.join(', ')}]  // ${info.file}`);
  }

  if (errors.length > 0) {
    process.exit(1);
  }
  
} else {
  // Default: print the JS block ready to paste into analysis.js
  console.log(`/**`);
  console.log(` * AUTO-GENERATED by generate-braid-param-order.js`);
  console.log(` * Parsed ${fnCount} functions from ${fileCount} .braid files`);
  console.log(` * Generated: ${new Date().toISOString()}`);
  console.log(` * `);
  console.log(` * To regenerate: node backend/scripts/generate-braid-param-order.js`);
  console.log(` */`);
  console.log(`const BRAID_PARAM_ORDER = {`);
  console.log(generateJSBlock(paramOrder));
  console.log(`};`);
  
  console.error(`\n✅ Generated param order for ${fnCount} functions from ${fileCount} files`);
  if (errors.length > 0) {
    process.exit(1);
  }
}
