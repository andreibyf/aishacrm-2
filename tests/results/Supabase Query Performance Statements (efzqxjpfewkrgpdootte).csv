query,rolname,calls,mean_time,min_time,max_time,total_time,rows_read,cache_hit_rate,prop_total_time,index_advisor_result
SELECT public.refresh_dashboard_stats(),postgres,1798,80.951116313682,21.680806,273.144624,145550.107132,1798,99.9998672566959041,24.55846379598189,null
"with tables as (
SELECT
  c.oid :: int8 AS id,
  nc.nspname AS schema,
  c.relname AS name,
  c.relrowsecurity AS rls_enabled,
  c.relforcerowsecurity AS rls_forced,
  CASE
    WHEN c.relreplident = $1 THEN $2
    WHEN c.relreplident = $3 THEN $4
    WHEN c.relreplident = $5 THEN $6
    ELSE $7
  END AS replica_identity,
  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,
  pg_size_pretty(
    pg_total_relation_size(format($9, nc.nspname, c.relname))
  ) AS size,
  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,
  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,
  obj_description(c.oid) AS comment,
  coalesce(pk.primary_keys, $10) as primary_keys,
  coalesce(
    jsonb_agg(relationships) filter (where relationships is not null),
    $11
  ) as relationships
FROM
  pg_namespace nc
  JOIN pg_class c ON nc.oid = c.relnamespace
  left join (
    select
      c.oid::int8 as table_id,
      jsonb_agg(
        jsonb_build_object(
          $12, c.oid::int8,
          $13, n.nspname,
          $14, c.relname,
          $15, a.attname
        )
        order by array_position(i.indkey, a.attnum)
      ) as primary_keys
    from
      pg_index i
      join pg_class c on i.indrelid = c.oid
      join pg_namespace n on c.relnamespace = n.oid
      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)
    where
      n.nspname IN ($16) AND
      
      i.indisprimary
    group by c.oid
  ) as pk
  on pk.table_id = c.oid
  left join (
    select
      c.oid :: int8 as id,
      c.conname as constraint_name,
      nsa.nspname as source_schema,
      csa.relname as source_table_name,
      sa.attname as source_column_name,
      nta.nspname as target_table_schema,
      cta.relname as target_table_name,
      ta.attname as target_column_name
    from
      pg_constraint c
    join (
      pg_attribute sa
      join pg_class csa on sa.attrelid = csa.oid
      join pg_namespace nsa on csa.relnamespace = nsa.oid
    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)
    join (
      pg_attribute ta
      join pg_class cta on ta.attrelid = cta.oid
      join pg_namespace nta on cta.relnamespace = nta.oid
    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)
    where
      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND
      
      c.contype = $19
  ) as relationships
  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)
  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)
WHERE
  nc.nspname IN ($20) AND
  
  
  c.relkind IN ($21, $22)
  AND NOT pg_is_other_temp_schema(nc.oid)
  AND (
    pg_has_role(c.relowner, $23)
    OR has_table_privilege(
      c.oid,
      $24
    )
    OR has_any_column_privilege(c.oid, $25)
  )
group by
  c.oid,
  c.relname,
  c.relrowsecurity,
  c.relforcerowsecurity,
  c.relreplident,
  nc.nspname,
  pk.primary_keys


)
  
select
  *
  
from tables",postgres,607,132.395836723229,7.98884,501.077961,80364.272891,33843,100.0000000000000000,13.559750144973409,null
SELECT name FROM pg_timezone_names,authenticator,218,204.911617619266,53.492648,1089.04436,44670.732641,260292,0,7.537229562524956,null
"with f as (
      
-- CTE with sane arg_modes, arg_names, and arg_types.
-- All three are always of the same length.
-- All three include all args, including OUT and TABLE args.
with functions as (
  select
    *,
    -- proargmodes is null when all arg modes are IN
    coalesce(
      p.proargmodes,
      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])
    ) as arg_modes,
    -- proargnames is null when all args are unnamed
    coalesce(
      p.proargnames,
      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])
    ) as arg_names,
    -- proallargtypes is null when all arg modes are IN
    coalesce(p.proallargtypes, p.proargtypes) as arg_types,
    array_cat(
      array_fill($3, array[pronargs - pronargdefaults]),
      array_fill($4, array[pronargdefaults])) as arg_has_defaults
  from
    pg_proc as p
  where
    p.prokind = $5
)
select
  f.oid as id,
  n.nspname as schema,
  f.proname as name,
  l.lanname as language,
  case
    when l.lanname = $6 then $7
    else f.prosrc
  end as definition,
  case
    when l.lanname = $8 then f.prosrc
    else pg_get_functiondef(f.oid)
  end as complete_statement,
  coalesce(f_args.args, $9) as args,
  pg_get_function_arguments(f.oid) as argument_types,
  pg_get_function_identity_arguments(f.oid) as identity_argument_types,
  f.prorettype as return_type_id,
  pg_get_function_result(f.oid) as return_type,
  nullif(rt.typrelid, $10) as return_type_relation_id,
  f.proretset as is_set_returning_function,
  case
    when f.provolatile = $11 then $12
    when f.provolatile = $13 then $14
    when f.provolatile = $15 then $16
  end as behavior,
  f.prosecdef as security_definer,
  f_config.config_params as config_params
from
  functions f
  left join pg_namespace n on f.pronamespace = n.oid
  left join pg_language l on f.prolang = l.oid
  left join pg_type rt on rt.oid = f.prorettype
  left join (
    select
      oid,
      jsonb_object_agg(param, value) filter (where param is not null) as config_params
    from
      (
        select
          oid,
          (string_to_array(unnest(proconfig), $17))[$18] as param,
          (string_to_array(unnest(proconfig), $19))[$20] as value
        from
          functions
      ) as t
    group by
      oid
  ) f_config on f_config.oid = f.oid
  left join (
    select
      oid,
      jsonb_agg(jsonb_build_object(
        $21, t2.mode,
        $22, name,
        $23, type_id,
        -- Cast null into false boolean
        $24, COALESCE(has_default, $25)
      )) as args
    from
      (
        select
          oid,
          unnest(arg_modes) as mode,
          unnest(arg_names) as name,
          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume
          -- integer, we need to cast it to be properly parsed
          unnest(arg_types)::int8 as type_id,
          unnest(arg_has_defaults) as has_default
        from
          functions
      ) as t1,
      lateral (
        select
          case
            when t1.mode = $26 then $27
            when t1.mode = $28 then $29
            when t1.mode = $30 then $31
            when t1.mode = $32 then $33
            else $34
          end as mode
      ) as t2
    group by
      t1.oid
  ) f_args on f_args.oid = f.oid

    )
    select
      f.*
    from f
   where schema NOT IN ($35,$36,$37)

-- source: dashboard
-- user: 81103985-99c3-4798-b10e-6b429d0fb12e
-- date: 2025-11-21T16:09:05.253Z",postgres,357,114.352343064426,66.79985,412.400913,40823.786474,59257,100.0000000000000000,6.888139774623385,null
"WITH pgrst_source AS (INSERT INTO ""public"".""performance_logs""(""db_query_time_ms"", ""duration_ms"", ""endpoint"", ""error_message"", ""error_stack"", ""ip_address"", ""method"", ""response_time_ms"", ""status_code"", ""tenant_id"", ""user_agent"", ""user_email"") SELECT ""pgrst_body"".""db_query_time_ms"", ""pgrst_body"".""duration_ms"", ""pgrst_body"".""endpoint"", ""pgrst_body"".""error_message"", ""pgrst_body"".""error_stack"", ""pgrst_body"".""ip_address"", ""pgrst_body"".""method"", ""pgrst_body"".""response_time_ms"", ""pgrst_body"".""status_code"", ""pgrst_body"".""tenant_id"", ""pgrst_body"".""user_agent"", ""pgrst_body"".""user_email"" FROM (SELECT $1 AS json_data) pgrst_payload, LATERAL (SELECT ""db_query_time_ms"", ""duration_ms"", ""endpoint"", ""error_message"", ""error_stack"", ""ip_address"", ""method"", ""response_time_ms"", ""status_code"", ""tenant_id"", ""user_agent"", ""user_email"" FROM json_to_recordset(pgrst_payload.json_data) AS _(""db_query_time_ms"" integer, ""duration_ms"" integer, ""endpoint"" text, ""error_message"" text, ""error_stack"" text, ""ip_address"" text, ""method"" text, ""response_time_ms"" integer, ""status_code"" integer, ""tenant_id"" uuid, ""user_agent"" text, ""user_email"" text) ) pgrst_body  RETURNING $2) SELECT $3 AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, array[]::text[] AS header, $4::text AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM (SELECT * FROM pgrst_source) _postgrest_t",service_role,52649,0.706914636460339,0.137098,120.864073,37218.3486949994,52649,99.9987875978723275,6.27979935558164,null
SELECT public.run_dashboard_funnel_refresh_job(),postgres,278,104.124010564748,0.484356,240.795611,28946.474937,278,99.9997645942723432,4.884097791263806,null
"with base_table_info as ( select c.oid::int8 as id, nc.nspname as schema, c.relname as name, c.relkind, c.relrowsecurity as rls_enabled, c.relforcerowsecurity as rls_forced, c.relreplident, c.relowner, obj_description(c.oid) as comment, fs.srvname as foreign_server_name, fdw.fdwname as foreign_data_wrapper_name, fdw_handler.proname as foreign_data_wrapper_handler from pg_class c join pg_namespace nc on nc.oid = c.relnamespace left join pg_foreign_table ft on ft.ftrelid = c.oid left join pg_foreign_server fs on fs.oid = ft.ftserver left join pg_foreign_data_wrapper fdw on fdw.oid = fs.srvfdw left join pg_proc fdw_handler on fdw.fdwhandler = fdw_handler.oid where c.oid = $1 and not pg_is_other_temp_schema(nc.oid) and ( pg_has_role(c.relowner, $2) or has_table_privilege( c.oid, $3 ) or has_any_column_privilege(c.oid, $4) ) ), table_stats as ( select b.id, case when b.relreplident = $5 then $6 when b.relreplident = $7 then $8 when b.relreplident = $9 then $10 else $11 end as replica_identity, pg_total_relation_size(format($12, b.schema, b.name))::int8 as bytes, pg_size_pretty(pg_total_relation_size(format($13, b.schema, b.name))) as size, pg_stat_get_live_tuples(b.id) as live_rows_estimate, pg_stat_get_dead_tuples(b.id) as dead_rows_estimate from base_table_info b where b.relkind in ($14, $15) ), primary_keys as ( select i.indrelid as table_id, jsonb_agg( jsonb_build_object( $16, n.nspname, $17, c.relname, $18, i.indrelid::int8, $19, a.attname ) order by array_position(i.indkey, a.attnum) ) as primary_keys from pg_index i join pg_class c on i.indrelid = c.oid join pg_namespace n on c.relnamespace = n.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisprimary group by i.indrelid ), index_cols as ( select i.indrelid as table_id, i.indkey, array_agg( a.attname order by array_position(i.indkey, a.attnum) ) as columns from pg_index i join pg_class c on i.indrelid = c.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisunique and i.indisprimary = $20 group by i.indrelid, i.indkey ), unique_indexes as ( select ic.table_id, jsonb_agg( jsonb_build_object( $21, n.nspname, $22, c.relname, $23, ic.table_id::int8, $24, ic.columns ) ) as unique_indexes from index_cols ic join pg_class c on c.oid = ic.table_id join pg_namespace n on n.oid = c.relnamespace group by ic.table_id ), relationships as ( select c.conrelid as source_id, c.confrelid as target_id, jsonb_build_object( $25, c.oid::int8, $26, c.conname, $27, c.confdeltype, $28, c.confupdtype, $29, nsa.nspname, $30, csa.relname, $31, sa.attname, $32, nta.nspname, $33, cta.relname, $34, ta.attname ) as rel_info from pg_constraint c join pg_class csa on c.conrelid = csa.oid join pg_namespace nsa on csa.relnamespace = nsa.oid join pg_attribute sa on (sa.attrelid = c.conrelid and sa.attnum = any(c.conkey)) join pg_class cta on c.confrelid = cta.oid join pg_namespace nta on cta.relnamespace = nta.oid join pg_attribute ta on (ta.attrelid = c.confrelid and ta.attnum = any(c.confkey)) where c.contype = $35 ), columns as ( select a.attrelid as table_id, jsonb_agg(jsonb_build_object( $36, (a.attrelid || $37 || a.attnum), $38, c.oid::int8, $39, nc.nspname, $40, c.relname, $41, a.attnum, $42, a.attname, $43, case when a.atthasdef then pg_get_expr(ad.adbin, ad.adrelid) else $44 end, $45, case when t.typtype = $46 then case when bt.typelem <> $47::oid and bt.typlen = $48 then $49 when nbt.nspname = $50 then format_type(t.typbasetype, $51) else $52 end else case when t.typelem <> $53::oid and t.typlen = $54 then $55 when nt.nspname = $56 then format_type(a.atttypid, $57) else $58 end end, $59, case when t.typtype = $60 then case when nt.nspname <> $61 then concat(nt.nspname, $62, coalesce(bt.typname, t.typname)) else coalesce(bt.typname, t.typname) end else coalesce(bt.typname, t.typname) end, $63, a.attidentity in ($64, $65), $66, case a.attidentity when $67 then $68 when $69 then $70 else $71 end, $72, a.attgenerated in ($73), $74, not (a.attnotnull or t.typtype = $75 and t.typnotnull), $76, ( b.relkind in ($77, $78) or (b.relkind in ($79, $80) and pg_column_is_updatable(b.id, a.attnum, $81)) ), $82, uniques.table_id is not null, $83, check_constraints.definition, $84, col_description(c.oid, a.attnum), $85, coalesce( ( select jsonb_agg(e.enumlabel order by e.enumsortorder) from pg_catalog.pg_enum e where e.enumtypid = coalesce(bt.oid, t.oid) or e.enumtypid = coalesce(bt.typelem, t.typelem) ), $86::jsonb ) ) order by a.attnum) as columns from pg_attribute a join base_table_info b on a.attrelid = b.id join pg_class c on a.attrelid = c.oid join pg_namespace nc on c.relnamespace = nc.oid left join pg_attrdef ad on (a.attrelid = ad.adrelid and a.attnum = ad.adnum) join pg_type t on a.atttypid = t.oid join pg_namespace nt on t.typnamespace = nt.oid left join pg_type bt on (t.typtype = $87 and t.typbasetype = bt.oid) left join pg_namespace nbt on bt.typnamespace = nbt.oid left join ( select conrelid as table_id, conkey[$88] as ordinal_position from pg_catalog.pg_constraint where contype = $89 and cardinality(conkey) = $90 group by conrelid, conkey[1] ) as uniques on uniques.table_id = a.attrelid and uniques.ordinal_position = a.attnum left join ( select distinct on (conrelid, conkey[1]) conrelid as table_id, conkey[$91] as ordinal_position, substring( pg_get_constraintdef(oid, $92), $93, length(pg_get_constraintdef(oid, $94)) - $95 ) as definition from pg_constraint where contype = $96 and cardinality(conkey) = $97 order by conrelid, conkey[1], oid asc ) as check_constraints on check_constraints.table_id = a.attrelid and check_constraints.ordinal_position = a.attnum where a.attnum > $98 and not a.attisdropped group by a.attrelid ) select case b.relkind when $99 then jsonb_build_object( $100, b.relkind, $101, b.id, $102, b.schema, $103, b.name, $104, b.rls_enabled, $105, b.rls_forced, $106, ts.replica_identity, $107, ts.bytes, $108, ts.size, $109, ts.live_rows_estimate, $110, ts.dead_rows_estimate, $111, b.comment, $112, coalesce(pk.primary_keys, $113::jsonb), $114, coalesce(ui.unique_indexes, $115::jsonb), $116, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $117::jsonb ), $118, coalesce(c.columns, $119::jsonb) ) when $120 then jsonb_build_object( $121, b.relkind, $122, b.id, $123, b.schema, $124, b.name, $125, b.rls_enabled, $126, b.rls_forced, $127, ts.replica_identity, $128, ts.bytes, $129, ts.size, $130, ts.live_rows_estimate, $131, ts.dead_rows_estimate, $132, b.comment, $133, coalesce(pk.primary_keys, $134::jsonb), $135, coalesce(ui.unique_indexes, $136::jsonb), $137, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $138::jsonb ), $139, coalesce(c.columns, $140::jsonb) ) when $141 then jsonb_build_object( $142, b.relkind, $143, b.id, $144, b.schema, $145, b.name, $146, (pg_relation_is_updatable(b.id, $147) & $148) = $149, $150, b.comment, $151, coalesce(c.columns, $152::jsonb) ) when $153 then jsonb_build_object( $154, b.relkind, $155, b.id, $156, b.schema, $157, b.name, $158, $159, $160, b.comment, $161, coalesce(c.columns, $162::jsonb) ) when $163 then jsonb_build_object( $164, b.relkind, $165, b.id, $166, b.schema, $167, b.name, $168, b.comment, $169, b.foreign_server_name, $170, b.foreign_data_wrapper_name, $171, b.foreign_data_wrapper_handler, $172, coalesce(c.columns, $173::jsonb) ) end as entity from base_table_info b left join table_stats ts on b.id = ts.id left join primary_keys pk on b.id = pk.table_id left join unique_indexes ui on b.id = ui.table_id left join columns c on b.id = c.table_id",postgres,1408,20.5206401455966,0.0549,95.587343,28893.061325,1407,100.0000000000000000,4.875085388027819,null
"select set_config('search_path', $1, true), set_config('role', $2, true), set_config('request.jwt.claims', $3, true), set_config('request.method', $4, true), set_config('request.path', $5, true), set_config('request.headers', $6, true), set_config('request.cookies', $7, true)",service_role,1055408,0.0268676809982496,0.014671,14.994558,28356.3654670041,1055408,100.0000000000000000,4.784529454694892,null
"with
      tables as (SELECT
  c.oid :: int8 AS id,
  nc.nspname AS schema,
  c.relname AS name,
  c.relrowsecurity AS rls_enabled,
  c.relforcerowsecurity AS rls_forced,
  CASE
    WHEN c.relreplident = $2 THEN $3
    WHEN c.relreplident = $4 THEN $5
    WHEN c.relreplident = $6 THEN $7
    ELSE $8
  END AS replica_identity,
  pg_total_relation_size(format($9, nc.nspname, c.relname)) :: int8 AS bytes,
  pg_size_pretty(
    pg_total_relation_size(format($10, nc.nspname, c.relname))
  ) AS size,
  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,
  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,
  obj_description(c.oid) AS comment,
  coalesce(pk.primary_keys, $11) as primary_keys,
  coalesce(
    jsonb_agg(relationships) filter (where relationships is not null),
    $12
  ) as relationships
FROM
  pg_namespace nc
  JOIN pg_class c ON nc.oid = c.relnamespace
  left join (
    select
      table_id,
      jsonb_agg(_pk.*) as primary_keys
    from (
      select
        n.nspname as schema,
        c.relname as table_name,
        a.attname as name,
        c.oid :: int8 as table_id
      from
        pg_index i,
        pg_class c,
        pg_attribute a,
        pg_namespace n
      where
        i.indrelid = c.oid
        and c.relnamespace = n.oid
        and a.attrelid = c.oid
        and a.attnum = any (i.indkey)
        and i.indisprimary
    ) as _pk
    group by table_id
  ) as pk
  on pk.table_id = c.oid
  left join (
    select
      c.oid :: int8 as id,
      c.conname as constraint_name,
      nsa.nspname as source_schema,
      csa.relname as source_table_name,
      sa.attname as source_column_name,
      nta.nspname as target_table_schema,
      cta.relname as target_table_name,
      ta.attname as target_column_name
    from
      pg_constraint c
    join (
      pg_attribute sa
      join pg_class csa on sa.attrelid = csa.oid
      join pg_namespace nsa on csa.relnamespace = nsa.oid
    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)
    join (
      pg_attribute ta
      join pg_class cta on ta.attrelid = cta.oid
      join pg_namespace nta on cta.relnamespace = nta.oid
    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)
    where
      c.contype = $13
  ) as relationships
  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)
  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)
WHERE
  c.relkind IN ($14, $15)
  AND NOT pg_is_other_temp_schema(nc.oid)
  AND (
    pg_has_role(c.relowner, $16)
    OR has_table_privilege(
      c.oid,
      $17
    )
    OR has_any_column_privilege(c.oid, $18)
  )
group by
  c.oid,
  c.relname,
  c.relrowsecurity,
  c.relforcerowsecurity,
  c.relreplident,
  nc.nspname,
  pk.primary_keys
),
      columns as (-- Adapted from information_schema.columns

SELECT
  c.oid :: int8 AS table_id,
  nc.nspname AS schema,
  c.relname AS table,
  (c.oid || $19 || a.attnum) AS id,
  a.attnum AS ordinal_position,
  a.attname AS name,
  CASE
    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)
    ELSE $20
  END AS default_value,
  CASE
    WHEN t.typtype = $21 THEN CASE
      WHEN bt.typelem <> $22 :: oid
      AND bt.typlen = $23 THEN $24
      WHEN nbt.nspname = $25 THEN format_type(t.typbasetype, $26)
      ELSE $27
    END
    ELSE CASE
      WHEN t.typelem <> $28 :: oid
      AND t.typlen = $29 THEN $30
      WHEN nt.nspname = $31 THEN format_type(a.atttypid, $32)
      ELSE $33
    END
  END AS data_type,
  COALESCE(bt.typname, t.typname) AS format,
  a.attidentity IN ($34, $35) AS is_identity,
  CASE
    a.attidentity
    WHEN $36 THEN $37
    WHEN $38 THEN $39
    ELSE $40
  END AS identity_generation,
  a.attgenerated IN ($41) AS is_generated,
  NOT (
    a.attnotnull
    OR t.typtype = $42 AND t.typnotnull
  ) AS is_nullable,
  (
    c.relkind IN ($43, $44)
    OR c.relkind IN ($45, $46) AND pg_column_is_updatable(c.oid, a.attnum, $47)
  ) AS is_updatable,
  uniques.table_id IS NOT NULL AS is_unique,
  check_constraints.definition AS ""check"",
  array_to_json(
    array(
      SELECT
        enumlabel
      FROM
        pg_catalog.pg_enum enums
      WHERE
        enums.enumtypid = coalesce(bt.oid, t.oid)
        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)
      ORDER BY
        enums.enumsortorder
    )
  ) AS enums,
  col_description(c.oid, a.attnum) AS comment
FROM
  pg_attribute a
  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid
  AND a.attnum = ad.adnum
  JOIN (
    pg_class c
    JOIN pg_namespace nc ON c.relnamespace = nc.oid
  ) ON a.attrelid = c.oid
  JOIN (
    pg_type t
    JOIN pg_namespace nt ON t.typnamespace = nt.oid
  ) ON a.atttypid = t.oid
  LEFT JOIN (
    pg_type bt
    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid
  ) ON t.typtype = $48
  AND t.typbasetype = bt.oid
  LEFT JOIN (
    SELECT DISTINCT ON (table_id, ordinal_position)
      conrelid AS table_id,
      conkey[$49] AS ordinal_position
    FROM pg_catalog.pg_constraint
    WHERE contype = $50 AND cardinality(conkey) = $51
  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum
  LEFT JOIN (
    -- We only select the first column check
    SELECT DISTINCT ON (table_id, ordinal_position)
      conrelid AS table_id,
      conkey[$52] AS ordinal_position,
      substring(
        pg_get_constraintdef(pg_constraint.oid, $53),
        $54,
        length(pg_get_constraintdef(pg_constraint.oid, $55)) - $56
      ) AS ""definition""
    FROM pg_constraint
    WHERE contype = $57 AND cardinality(conkey) = $58
    ORDER BY table_id, ordinal_position, oid asc
  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum
WHERE
  NOT pg_is_other_temp_schema(nc.oid)
  AND a.attnum > $59
  AND NOT a.attisdropped
  AND (c.relkind IN ($60, $61, $62, $63, $64))
  AND (
    pg_has_role(c.relowner, $65)
    OR has_column_privilege(
      c.oid,
      a.attnum,
      $66
    )
  )
)
    select
      *,
      COALESCE(
  (
    SELECT
      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)
    FROM
      columns
  ),
  $67
) AS columns
    from tables
where schema in ($1)

-- source: api
-- user: 81103985-99c3-4798-b10e-6b429d0fb12e
-- date: 2025-12-09T20:03:08.692Z",supabase_read_only_user,28,838.711858964286,751.022046,959.476961,23483.932051,1667,100.0000000000000000,3.962410653114422,null
"with tables as (
SELECT
  c.oid :: int8 AS id,
  nc.nspname AS schema,
  c.relname AS name,
  c.relrowsecurity AS rls_enabled,
  c.relforcerowsecurity AS rls_forced,
  CASE
    WHEN c.relreplident = $1 THEN $2
    WHEN c.relreplident = $3 THEN $4
    WHEN c.relreplident = $5 THEN $6
    ELSE $7
  END AS replica_identity,
  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,
  pg_size_pretty(
    pg_total_relation_size(format($9, nc.nspname, c.relname))
  ) AS size,
  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,
  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,
  obj_description(c.oid) AS comment,
  coalesce(pk.primary_keys, $10) as primary_keys,
  coalesce(
    jsonb_agg(relationships) filter (where relationships is not null),
    $11
  ) as relationships
FROM
  pg_namespace nc
  JOIN pg_class c ON nc.oid = c.relnamespace
  left join (
    select
      c.oid::int8 as table_id,
      jsonb_agg(
        jsonb_build_object(
          $12, c.oid::int8,
          $13, n.nspname,
          $14, c.relname,
          $15, a.attname
        )
        order by array_position(i.indkey, a.attnum)
      ) as primary_keys
    from
      pg_index i
      join pg_class c on i.indrelid = c.oid
      join pg_namespace n on c.relnamespace = n.oid
      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)
    where
      n.nspname IN ($16) AND
      
      i.indisprimary
    group by c.oid
  ) as pk
  on pk.table_id = c.oid
  left join (
    select
      c.oid :: int8 as id,
      c.conname as constraint_name,
      nsa.nspname as source_schema,
      csa.relname as source_table_name,
      sa.attname as source_column_name,
      nta.nspname as target_table_schema,
      cta.relname as target_table_name,
      ta.attname as target_column_name
    from
      pg_constraint c
    join (
      pg_attribute sa
      join pg_class csa on sa.attrelid = csa.oid
      join pg_namespace nsa on csa.relnamespace = nsa.oid
    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)
    join (
      pg_attribute ta
      join pg_class cta on ta.attrelid = cta.oid
      join pg_namespace nta on cta.relnamespace = nta.oid
    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)
    where
      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND
      
      c.contype = $19
  ) as relationships
  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)
  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)
WHERE
  nc.nspname IN ($20) AND
  
  
  c.relkind IN ($21, $22)
  AND NOT pg_is_other_temp_schema(nc.oid)
  AND (
    pg_has_role(c.relowner, $23)
    OR has_table_privilege(
      c.oid,
      $24
    )
    OR has_any_column_privilege(c.oid, $25)
  )
group by
  c.oid,
  c.relname,
  c.relrowsecurity,
  c.relforcerowsecurity,
  c.relreplident,
  nc.nspname,
  pk.primary_keys


)
  , columns as (
-- Adapted from information_schema.columns

SELECT
  c.oid :: int8 AS table_id,
  nc.nspname AS schema,
  c.relname AS table,
  (c.oid || $26 || a.attnum) AS id,
  a.attnum AS ordinal_position,
  a.attname AS name,
  CASE
    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)
    ELSE $27
  END AS default_value,
  CASE
    WHEN t.typtype = $28 THEN CASE
      WHEN bt.typelem <> $29 :: oid
      AND bt.typlen = $30 THEN $31
      WHEN nbt.nspname = $32 THEN format_type(t.typbasetype, $33)
      ELSE $34
    END
    ELSE CASE
      WHEN t.typelem <> $35 :: oid
      AND t.typlen = $36 THEN $37
      WHEN nt.nspname = $38 THEN format_type(a.atttypid, $39)
      ELSE $40
    END
  END AS data_type,
  COALESCE(bt.typname, t.typname) AS format,
  a.attidentity IN ($41, $42) AS is_identity,
  CASE
    a.attidentity
    WHEN $43 THEN $44
    WHEN $45 THEN $46
    ELSE $47
  END AS identity_generation,
  a.attgenerated IN ($48) AS is_generated,
  NOT (
    a.attnotnull
    OR t.typtype = $49 AND t.typnotnull
  ) AS is_nullable,
  (
    c.relkind IN ($50, $51)
    OR c.relkind IN ($52, $53) AND pg_column_is_updatable(c.oid, a.attnum, $54)
  ) AS is_updatable,
  uniques.table_id IS NOT NULL AS is_unique,
  check_constraints.definition AS ""check"",
  array_to_json(
    array(
      SELECT
        enumlabel
      FROM
        pg_catalog.pg_enum enums
      WHERE
        enums.enumtypid = coalesce(bt.oid, t.oid)
        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)
      ORDER BY
        enums.enumsortorder
    )
  ) AS enums,
  col_description(c.oid, a.attnum) AS comment
FROM
  pg_attribute a
  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid
  AND a.attnum = ad.adnum
  JOIN (
    pg_class c
    JOIN pg_namespace nc ON c.relnamespace = nc.oid
  ) ON a.attrelid = c.oid
  JOIN (
    pg_type t
    JOIN pg_namespace nt ON t.typnamespace = nt.oid
  ) ON a.atttypid = t.oid
  LEFT JOIN (
    pg_type bt
    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid
  ) ON t.typtype = $55
  AND t.typbasetype = bt.oid
  LEFT JOIN (
    SELECT DISTINCT ON (table_id, ordinal_position)
      conrelid AS table_id,
      conkey[$56] AS ordinal_position
    FROM pg_catalog.pg_constraint
    WHERE contype = $57 AND cardinality(conkey) = $58
  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum
  LEFT JOIN (
    -- We only select the first column check
    SELECT DISTINCT ON (table_id, ordinal_position)
      conrelid AS table_id,
      conkey[$59] AS ordinal_position,
      substring(
        pg_get_constraintdef(pg_constraint.oid, $60),
        $61,
        length(pg_get_constraintdef(pg_constraint.oid, $62)) - $63
      ) AS ""definition""
    FROM pg_constraint
    WHERE contype = $64 AND cardinality(conkey) = $65
    ORDER BY table_id, ordinal_position, oid asc
  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum
WHERE
  nc.nspname IN ($66) AND
  
  
  
  
  NOT pg_is_other_temp_schema(nc.oid)
  AND a.attnum > $67
  AND NOT a.attisdropped
  AND (c.relkind IN ($68, $69, $70, $71, $72))
  AND (
    pg_has_role(c.relowner, $73)
    OR has_column_privilege(
      c.oid,
      a.attnum,
      $74
    )
  )


)
select
  *
  , 
COALESCE(
  (
    SELECT
      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)
    FROM
      columns
  ),
  $75
) AS columns
from tables",postgres,38,561.013206578947,186.852053,682.456564,21318.50185,2221,100.0000000000000000,3.5970406768095917,null
"with tables as (
SELECT
  c.oid :: int8 AS id,
  nc.nspname AS schema,
  c.relname AS name,
  c.relrowsecurity AS rls_enabled,
  c.relforcerowsecurity AS rls_forced,
  CASE
    WHEN c.relreplident = $1 THEN $2
    WHEN c.relreplident = $3 THEN $4
    WHEN c.relreplident = $5 THEN $6
    ELSE $7
  END AS replica_identity,
  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,
  pg_size_pretty(
    pg_total_relation_size(format($9, nc.nspname, c.relname))
  ) AS size,
  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,
  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,
  obj_description(c.oid) AS comment,
  coalesce(pk.primary_keys, $10) as primary_keys,
  coalesce(
    jsonb_agg(relationships) filter (where relationships is not null),
    $11
  ) as relationships
FROM
  pg_namespace nc
  JOIN pg_class c ON nc.oid = c.relnamespace
  left join (
    select
      c.oid::int8 as table_id,
      jsonb_agg(
        jsonb_build_object(
          $12, c.oid::int8,
          $13, n.nspname,
          $14, c.relname,
          $15, a.attname
        )
        order by array_position(i.indkey, a.attnum)
      ) as primary_keys
    from
      pg_index i
      join pg_class c on i.indrelid = c.oid
      join pg_namespace n on c.relnamespace = n.oid
      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)
    where
      i.indisprimary
    group by c.oid
  ) as pk
  on pk.table_id = c.oid
  left join (
    select
      c.oid :: int8 as id,
      c.conname as constraint_name,
      nsa.nspname as source_schema,
      csa.relname as source_table_name,
      sa.attname as source_column_name,
      nta.nspname as target_table_schema,
      cta.relname as target_table_name,
      ta.attname as target_column_name
    from
      pg_constraint c
    join (
      pg_attribute sa
      join pg_class csa on sa.attrelid = csa.oid
      join pg_namespace nsa on csa.relnamespace = nsa.oid
    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)
    join (
      pg_attribute ta
      join pg_class cta on ta.attrelid = cta.oid
      join pg_namespace nta on cta.relnamespace = nta.oid
    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)
    where
      c.contype = $16
  ) as relationships
  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)
  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)
WHERE
  c.relkind IN ($17, $18)
  AND NOT pg_is_other_temp_schema(nc.oid)
  AND (
    pg_has_role(c.relowner, $19)
    OR has_table_privilege(
      c.oid,
      $20
    )
    OR has_any_column_privilege(c.oid, $21)
  )
group by
  c.oid,
  c.relname,
  c.relrowsecurity,
  c.relforcerowsecurity,
  c.relreplident,
  nc.nspname,
  pk.primary_keys
)
  , columns as (
-- Adapted from information_schema.columns

SELECT
  c.oid :: int8 AS table_id,
  nc.nspname AS schema,
  c.relname AS table,
  (c.oid || $22 || a.attnum) AS id,
  a.attnum AS ordinal_position,
  a.attname AS name,
  CASE
    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)
    ELSE $23
  END AS default_value,
  CASE
    WHEN t.typtype = $24 THEN CASE
      WHEN bt.typelem <> $25 :: oid
      AND bt.typlen = $26 THEN $27
      WHEN nbt.nspname = $28 THEN format_type(t.typbasetype, $29)
      ELSE $30
    END
    ELSE CASE
      WHEN t.typelem <> $31 :: oid
      AND t.typlen = $32 THEN $33
      WHEN nt.nspname = $34 THEN format_type(a.atttypid, $35)
      ELSE $36
    END
  END AS data_type,
  COALESCE(bt.typname, t.typname) AS format,
  a.attidentity IN ($37, $38) AS is_identity,
  CASE
    a.attidentity
    WHEN $39 THEN $40
    WHEN $41 THEN $42
    ELSE $43
  END AS identity_generation,
  a.attgenerated IN ($44) AS is_generated,
  NOT (
    a.attnotnull
    OR t.typtype = $45 AND t.typnotnull
  ) AS is_nullable,
  (
    c.relkind IN ($46, $47)
    OR c.relkind IN ($48, $49) AND pg_column_is_updatable(c.oid, a.attnum, $50)
  ) AS is_updatable,
  uniques.table_id IS NOT NULL AS is_unique,
  check_constraints.definition AS ""check"",
  array_to_json(
    array(
      SELECT
        enumlabel
      FROM
        pg_catalog.pg_enum enums
      WHERE
        enums.enumtypid = coalesce(bt.oid, t.oid)
        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)
      ORDER BY
        enums.enumsortorder
    )
  ) AS enums,
  col_description(c.oid, a.attnum) AS comment
FROM
  pg_attribute a
  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid
  AND a.attnum = ad.adnum
  JOIN (
    pg_class c
    JOIN pg_namespace nc ON c.relnamespace = nc.oid
  ) ON a.attrelid = c.oid
  JOIN (
    pg_type t
    JOIN pg_namespace nt ON t.typnamespace = nt.oid
  ) ON a.atttypid = t.oid
  LEFT JOIN (
    pg_type bt
    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid
  ) ON t.typtype = $51
  AND t.typbasetype = bt.oid
  LEFT JOIN (
    SELECT DISTINCT ON (table_id, ordinal_position)
      conrelid AS table_id,
      conkey[$52] AS ordinal_position
    FROM pg_catalog.pg_constraint
    WHERE contype = $53 AND cardinality(conkey) = $54
  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum
  LEFT JOIN (
    -- We only select the first column check
    SELECT DISTINCT ON (table_id, ordinal_position)
      conrelid AS table_id,
      conkey[$55] AS ordinal_position,
      substring(
        pg_get_constraintdef(pg_constraint.oid, $56),
        $57,
        length(pg_get_constraintdef(pg_constraint.oid, $58)) - $59
      ) AS ""definition""
    FROM pg_constraint
    WHERE contype = $60 AND cardinality(conkey) = $61
    ORDER BY table_id, ordinal_position, oid asc
  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum
WHERE
  NOT pg_is_other_temp_schema(nc.oid)
  AND a.attnum > $62
  AND NOT a.attisdropped
  AND (c.relkind IN ($63, $64, $65, $66, $67))
  AND (
    pg_has_role(c.relowner, $68)
    OR has_column_privilege(
      c.oid,
      a.attnum,
      $69
    )
  )
)
  select
    *
    , 
COALESCE(
  (
    SELECT
      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)
    FROM
      columns
  ),
  $70
) AS columns
  from tables where name = $71 and schema = $72",postgres,167,98.8819648203593,56.181929,315.002456,16513.288125,167,100.0000000000000000,2.786263758656277,null
"WITH pgrst_source AS ( SELECT ""public"".""performance_logs"".* FROM ""public"".""performance_logs"" WHERE  ""public"".""performance_logs"".""endpoint"" <> $1 AND  ""public"".""performance_logs"".""endpoint"" <> $2   LIMIT $3 OFFSET $4 ) , pgrst_source_count AS (SELECT $7  FROM ""public"".""performance_logs"" WHERE  ""public"".""performance_logs"".""endpoint"" <> $5 AND  ""public"".""performance_logs"".""endpoint"" <> $6) SELECT (SELECT pg_catalog.count(*) FROM pgrst_source_count) AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, $8::text AS body, nullif(current_setting($9, $10), $11) AS response_headers, nullif(current_setting($12, $13), $14) AS response_status, $15 AS response_inserted FROM ( SELECT * FROM pgrst_source ) _postgrest_t",service_role,1558,10.0878551129653,7.634582,205.270927,15716.878266,1558,100.0000000000000000,2.6518866491205433,null
"SELECT
    tbl.schemaname,
    tbl.tablename,
    tbl.quoted_name,
    tbl.is_table,
    json_agg(a) as columns
  FROM
    (
      SELECT
        n.nspname as schemaname,
        c.relname as tablename,
        (quote_ident(n.nspname) || $1 || quote_ident(c.relname)) as quoted_name,
        $2 as is_table
      FROM
        pg_catalog.pg_class c
        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
      WHERE
        c.relkind = $3
        AND n.nspname not in ($4, $5, $6)
        AND n.nspname not like $7
        AND n.nspname not like $8
        AND has_schema_privilege(n.oid, $9) = $10
        AND has_table_privilege(quote_ident(n.nspname) || $11 || quote_ident(c.relname), $12) = $13
      union all
      SELECT
        n.nspname as schemaname,
        c.relname as tablename,
        (quote_ident(n.nspname) || $14 || quote_ident(c.relname)) as quoted_name,
        $15 as is_table
      FROM
        pg_catalog.pg_class c
        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
      WHERE
        c.relkind in ($16, $17)
        AND n.nspname not in ($18, $19, $20)
        AND n.nspname not like $21
        AND n.nspname not like $22
        AND has_schema_privilege(n.oid, $23) = $24
        AND has_table_privilege(quote_ident(n.nspname) || $25 || quote_ident(c.relname), $26) = $27
    ) as tbl
    LEFT JOIN (
      SELECT
        attrelid,
        attname,
        format_type(atttypid, atttypmod) as data_type,
        attnum,
        attisdropped
      FROM
        pg_attribute
    ) as a ON (
      a.attrelid = tbl.quoted_name::regclass
      AND a.attnum > $28
      AND NOT a.attisdropped
      AND has_column_privilege(tbl.quoted_name, a.attname, $29)
    )
  
  GROUP BY schemaname, tablename, quoted_name, is_table",postgres,276,43.083233307971,13.011658,178.980472,11890.972393,27967,100.0000000000000000,2.006346960278585,null
"with
      tables as (SELECT
  c.oid :: int8 AS id,
  nc.nspname AS schema,
  c.relname AS name,
  c.relrowsecurity AS rls_enabled,
  c.relforcerowsecurity AS rls_forced,
  CASE
    WHEN c.relreplident = $5 THEN $6
    WHEN c.relreplident = $7 THEN $8
    WHEN c.relreplident = $9 THEN $10
    ELSE $11
  END AS replica_identity,
  pg_total_relation_size(format($12, nc.nspname, c.relname)) :: int8 AS bytes,
  pg_size_pretty(
    pg_total_relation_size(format($13, nc.nspname, c.relname))
  ) AS size,
  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,
  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,
  obj_description(c.oid) AS comment,
  coalesce(pk.primary_keys, $14) as primary_keys,
  coalesce(
    jsonb_agg(relationships) filter (where relationships is not null),
    $15
  ) as relationships
FROM
  pg_namespace nc
  JOIN pg_class c ON nc.oid = c.relnamespace
  left join (
    select
      table_id,
      jsonb_agg(_pk.*) as primary_keys
    from (
      select
        n.nspname as schema,
        c.relname as table_name,
        a.attname as name,
        c.oid :: int8 as table_id
      from
        pg_index i,
        pg_class c,
        pg_attribute a,
        pg_namespace n
      where
        i.indrelid = c.oid
        and c.relnamespace = n.oid
        and a.attrelid = c.oid
        and a.attnum = any (i.indkey)
        and i.indisprimary
    ) as _pk
    group by table_id
  ) as pk
  on pk.table_id = c.oid
  left join (
    select
      c.oid :: int8 as id,
      c.conname as constraint_name,
      nsa.nspname as source_schema,
      csa.relname as source_table_name,
      sa.attname as source_column_name,
      nta.nspname as target_table_schema,
      cta.relname as target_table_name,
      ta.attname as target_column_name
    from
      pg_constraint c
    join (
      pg_attribute sa
      join pg_class csa on sa.attrelid = csa.oid
      join pg_namespace nsa on csa.relnamespace = nsa.oid
    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)
    join (
      pg_attribute ta
      join pg_class cta on ta.attrelid = cta.oid
      join pg_namespace nta on cta.relnamespace = nta.oid
    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)
    where
      c.contype = $16
  ) as relationships
  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)
  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)
WHERE
  c.relkind IN ($17, $18)
  AND NOT pg_is_other_temp_schema(nc.oid)
  AND (
    pg_has_role(c.relowner, $19)
    OR has_table_privilege(
      c.oid,
      $20
    )
    OR has_any_column_privilege(c.oid, $21)
  )
group by
  c.oid,
  c.relname,
  c.relrowsecurity,
  c.relforcerowsecurity,
  c.relreplident,
  nc.nspname,
  pk.primary_keys
),
      columns as (-- Adapted from information_schema.columns

SELECT
  c.oid :: int8 AS table_id,
  nc.nspname AS schema,
  c.relname AS table,
  (c.oid || $22 || a.attnum) AS id,
  a.attnum AS ordinal_position,
  a.attname AS name,
  CASE
    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)
    ELSE $23
  END AS default_value,
  CASE
    WHEN t.typtype = $24 THEN CASE
      WHEN bt.typelem <> $25 :: oid
      AND bt.typlen = $26 THEN $27
      WHEN nbt.nspname = $28 THEN format_type(t.typbasetype, $29)
      ELSE $30
    END
    ELSE CASE
      WHEN t.typelem <> $31 :: oid
      AND t.typlen = $32 THEN $33
      WHEN nt.nspname = $34 THEN format_type(a.atttypid, $35)
      ELSE $36
    END
  END AS data_type,
  COALESCE(bt.typname, t.typname) AS format,
  a.attidentity IN ($37, $38) AS is_identity,
  CASE
    a.attidentity
    WHEN $39 THEN $40
    WHEN $41 THEN $42
    ELSE $43
  END AS identity_generation,
  a.attgenerated IN ($44) AS is_generated,
  NOT (
    a.attnotnull
    OR t.typtype = $45 AND t.typnotnull
  ) AS is_nullable,
  (
    c.relkind IN ($46, $47)
    OR c.relkind IN ($48, $49) AND pg_column_is_updatable(c.oid, a.attnum, $50)
  ) AS is_updatable,
  uniques.table_id IS NOT NULL AS is_unique,
  check_constraints.definition AS ""check"",
  array_to_json(
    array(
      SELECT
        enumlabel
      FROM
        pg_catalog.pg_enum enums
      WHERE
        enums.enumtypid = coalesce(bt.oid, t.oid)
        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)
      ORDER BY
        enums.enumsortorder
    )
  ) AS enums,
  col_description(c.oid, a.attnum) AS comment
FROM
  pg_attribute a
  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid
  AND a.attnum = ad.adnum
  JOIN (
    pg_class c
    JOIN pg_namespace nc ON c.relnamespace = nc.oid
  ) ON a.attrelid = c.oid
  JOIN (
    pg_type t
    JOIN pg_namespace nt ON t.typnamespace = nt.oid
  ) ON a.atttypid = t.oid
  LEFT JOIN (
    pg_type bt
    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid
  ) ON t.typtype = $51
  AND t.typbasetype = bt.oid
  LEFT JOIN (
    SELECT DISTINCT ON (table_id, ordinal_position)
      conrelid AS table_id,
      conkey[$52] AS ordinal_position
    FROM pg_catalog.pg_constraint
    WHERE contype = $53 AND cardinality(conkey) = $54
  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum
  LEFT JOIN (
    -- We only select the first column check
    SELECT DISTINCT ON (table_id, ordinal_position)
      conrelid AS table_id,
      conkey[$55] AS ordinal_position,
      substring(
        pg_get_constraintdef(pg_constraint.oid, $56),
        $57,
        length(pg_get_constraintdef(pg_constraint.oid, $58)) - $59
      ) AS ""definition""
    FROM pg_constraint
    WHERE contype = $60 AND cardinality(conkey) = $61
    ORDER BY table_id, ordinal_position, oid asc
  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum
WHERE
  NOT pg_is_other_temp_schema(nc.oid)
  AND a.attnum > $62
  AND NOT a.attisdropped
  AND (c.relkind IN ($63, $64, $65, $66, $67))
  AND (
    pg_has_role(c.relowner, $68)
    OR has_column_privilege(
      c.oid,
      a.attnum,
      $69
    )
  )
)
    select
      *,
      COALESCE(
  (
    SELECT
      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)
    FROM
      columns
  ),
  $70
) AS columns
    from tables
where schema in ($1, $2, $3, $4)

-- source: api
-- user: 81103985-99c3-4798-b10e-6b429d0fb12e
-- date: 2025-12-09T18:48:03.515Z",supabase_read_only_user,9,1271.60584222222,1216.132687,1382.484854,11444.45258,821,100.0000000000000000,1.9310063035258962,null
"with records as (
  select
    c.oid::int8 as ""id"",
    case c.relkind
      when $1 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $2,
        $3,
        $4
      )
      when $5 then concat(
        $6, concat(nc.nspname, $7, c.relname), $8,
        pg_get_viewdef(concat(nc.nspname, $9, c.relname), $10)
      )
      when $11 then concat(
        $12, concat(nc.nspname, $13, c.relname), $14,
        pg_get_viewdef(concat(nc.nspname, $15, c.relname), $16)
      )
      when $17 then concat($18, nc.nspname, $19, c.relname, $20)
      when $21 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $22,
        $23,
        $24
      )
    end as ""sql""
  from
    pg_namespace nc
    join pg_class c on nc.oid = c.relnamespace
  where
    c.relkind in ($25, $26, $27, $28, $29)
    and not pg_is_other_temp_schema(nc.oid)
    and (
      pg_has_role(c.relowner, $30)
      or has_table_privilege(
        c.oid,
        $31
      )
      or has_any_column_privilege(c.oid, $32)
    )
    and nc.nspname IN ($33)
  order by c.relname asc
  limit $34
  offset $35
)
select
  jsonb_build_object(
    $36, coalesce(jsonb_agg(
      jsonb_build_object(
        $37, r.id,
        $38, r.sql
      )
    ), $39::jsonb)
  ) ""data""
from records r",postgres,1,9989.949099,9989.949099,9989.949099,9989.949099,1,100.0000000000000000,1.6855899875703664,null
"SELECT
  pol.oid :: int8 AS id,
  n.nspname AS schema,
  c.relname AS table,
  c.oid :: int8 AS table_id,
  pol.polname AS name,
  CASE
    WHEN pol.polpermissive THEN $1 :: text
    ELSE $2 :: text
  END AS action,
  CASE
    WHEN pol.polroles = $3 :: oid [] THEN array_to_json(
      string_to_array($4 :: text, $5 :: text) :: name []
    )
    ELSE array_to_json(
      ARRAY(
        SELECT
          pg_roles.rolname
        FROM
          pg_roles
        WHERE
          pg_roles.oid = ANY (pol.polroles)
        ORDER BY
          pg_roles.rolname
      )
    )
  END AS roles,
  CASE
    pol.polcmd
    WHEN $6 :: ""char"" THEN $7 :: text
    WHEN $8 :: ""char"" THEN $9 :: text
    WHEN $10 :: ""char"" THEN $11 :: text
    WHEN $12 :: ""char"" THEN $13 :: text
    WHEN $14 :: ""char"" THEN $15 :: text
    ELSE $16 :: text
  END AS command,
  pg_get_expr(pol.polqual, pol.polrelid) AS definition,
  pg_get_expr(pol.polwithcheck, pol.polrelid) AS check
FROM
  pg_policy pol
  JOIN pg_class c ON c.oid = pol.polrelid
  LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE
  n.nspname NOT IN ($17,$18,$19)",postgres,473,20.934658167019,3.556667,115.062176,9902.093313,44104,100.0000000000000000,1.6707662050100978,null
"with records as (
  select
    c.oid::int8 as ""id"",
    case c.relkind
      when $1 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $2,
        $3,
        $4
      )
      when $5 then concat(
        $6, concat(nc.nspname, $7, c.relname), $8,
        pg_get_viewdef(concat(nc.nspname, $9, c.relname), $10)
      )
      when $11 then concat(
        $12, concat(nc.nspname, $13, c.relname), $14,
        pg_get_viewdef(concat(nc.nspname, $15, c.relname), $16)
      )
      when $17 then concat($18, nc.nspname, $19, c.relname, $20)
      when $21 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $22,
        $23,
        $24
      )
    end as ""sql""
  from
    pg_namespace nc
    join pg_class c on nc.oid = c.relnamespace
  where
    c.relkind in ($25, $26, $27, $28, $29)
    and not pg_is_other_temp_schema(nc.oid)
    and (
      pg_has_role(c.relowner, $30)
      or has_table_privilege(
        c.oid,
        $31
      )
      or has_any_column_privilege(c.oid, $32)
    )
    and nc.nspname IN ($33)
  order by c.relname asc
  limit $34
  offset $35
)
select
  jsonb_build_object(
    $36, coalesce(jsonb_agg(
      jsonb_build_object(
        $37, r.id,
        $38, r.sql
      )
    ), $39::jsonb)
  ) ""data""
from records r",postgres,1,9715.533706,9715.533706,9715.533706,9715.533706,1,100.0000000000000000,1.639288266281087,null
"with records as (
  select
    c.oid::int8 as ""id"",
    case c.relkind
      when $1 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $2,
        $3,
        $4
      )
      when $5 then concat(
        $6, concat(nc.nspname, $7, c.relname), $8,
        pg_get_viewdef(concat(nc.nspname, $9, c.relname), $10)
      )
      when $11 then concat(
        $12, concat(nc.nspname, $13, c.relname), $14,
        pg_get_viewdef(concat(nc.nspname, $15, c.relname), $16)
      )
      when $17 then concat($18, nc.nspname, $19, c.relname, $20)
      when $21 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $22,
        $23,
        $24
      )
    end as ""sql""
  from
    pg_namespace nc
    join pg_class c on nc.oid = c.relnamespace
  where
    c.relkind in ($25, $26, $27, $28, $29)
    and not pg_is_other_temp_schema(nc.oid)
    and (
      pg_has_role(c.relowner, $30)
      or has_table_privilege(
        c.oid,
        $31
      )
      or has_any_column_privilege(c.oid, $32)
    )
    and nc.nspname IN ($33)
  order by c.relname asc
  limit $34
  offset $35
)
select
  jsonb_build_object(
    $36, coalesce(jsonb_agg(
      jsonb_build_object(
        $37, r.id,
        $38, r.sql
      )
    ), $39::jsonb)
  ) ""data""
from records r",postgres,1,9476.852596,9476.852596,9476.852596,9476.852596,1,100.0000000000000000,1.5990159400408606,null
"with records as (
  select
    c.oid::int8 as ""id"",
    case c.relkind
      when $1 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $2,
        $3,
        $4
      )
      when $5 then concat(
        $6, concat(nc.nspname, $7, c.relname), $8,
        pg_get_viewdef(concat(nc.nspname, $9, c.relname), $10)
      )
      when $11 then concat(
        $12, concat(nc.nspname, $13, c.relname), $14,
        pg_get_viewdef(concat(nc.nspname, $15, c.relname), $16)
      )
      when $17 then concat($18, nc.nspname, $19, c.relname, $20)
      when $21 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $22,
        $23,
        $24
      )
    end as ""sql""
  from
    pg_namespace nc
    join pg_class c on nc.oid = c.relnamespace
  where
    c.relkind in ($25, $26, $27, $28, $29)
    and not pg_is_other_temp_schema(nc.oid)
    and (
      pg_has_role(c.relowner, $30)
      or has_table_privilege(
        c.oid,
        $31
      )
      or has_any_column_privilege(c.oid, $32)
    )
    and nc.nspname IN ($33)
  order by c.relname asc
  limit $34
  offset $35
)
select
  jsonb_build_object(
    $36, coalesce(jsonb_agg(
      jsonb_build_object(
        $37, r.id,
        $38, r.sql
      )
    ), $39::jsonb)
  ) ""data""
from records r",postgres,1,9314.105512,9314.105512,9314.105512,9314.105512,1,100.0000000000000000,1.571555854651223,null
"with records as (
  select
    c.oid::int8 as ""id"",
    case c.relkind
      when $1 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $2,
        $3,
        $4
      )
      when $5 then concat(
        $6, concat(nc.nspname, $7, c.relname), $8,
        pg_get_viewdef(concat(nc.nspname, $9, c.relname), $10)
      )
      when $11 then concat(
        $12, concat(nc.nspname, $13, c.relname), $14,
        pg_get_viewdef(concat(nc.nspname, $15, c.relname), $16)
      )
      when $17 then concat($18, nc.nspname, $19, c.relname, $20)
      when $21 then pg_temp.pg_get_tabledef(
        concat(nc.nspname),
        concat(c.relname),
        $22,
        $23,
        $24
      )
    end as ""sql""
  from
    pg_namespace nc
    join pg_class c on nc.oid = c.relnamespace
  where
    c.relkind in ($25, $26, $27, $28, $29)
    and not pg_is_other_temp_schema(nc.oid)
    and (
      pg_has_role(c.relowner, $30)
      or has_table_privilege(
        c.oid,
        $31
      )
      or has_any_column_privilege(c.oid, $32)
    )
    and nc.nspname IN ($33)
  order by c.relname asc
  limit $34
  offset $35
)
select
  jsonb_build_object(
    $36, coalesce(jsonb_agg(
      jsonb_build_object(
        $37, r.id,
        $38, r.sql
      )
    ), $39::jsonb)
  ) ""data""
from records r",postgres,1,9078.091104,9078.091104,9078.091104,9078.091104,1,100.0000000000000000,1.531733477269243,null